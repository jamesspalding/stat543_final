---
title: "Untitled"
author: "James Spalding"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, include = F, message = F)
library(tidyverse)
library(VGAM)
select = dplyr::select
```
# Introduction

There is a constant struggle to ensure people are being given access to the correct amount of aid they need to survive. Some programs target some of the poorest populations to ensure they are being properly taken care of. Unfortunately, some of these poorer communities are unable to correctly and accurately document that they qualify for the amount of aid they tend to need. The goal of this project is to take observable attributes of a given household and bucket them into different poverty levels.

The data provided for this includes 142 predictor variables where each row is an individual that was observed. Descriptions of the variables are as follows:
- v2a1, Monthly rent payment
- hacdor, =1 Overcrowding by bedrooms
- rooms,  number of all rooms in the house
- hacapo, =1 Overcrowding by rooms
- v14a, =1 has bathroom in the household
- refrig, =1 if the household has refrigerator
- v18q, owns a tablet
- v18q1, number of tablets household owns
- r4h1, Males younger than 12 years of age
- r4h2, Males 12 years of age and older
- r4h3, Total males in the household
- r4m1, Females younger than 12 years of age
- r4m2, Females 12 years of age and older
- r4m3, Total females in the household
- r4t1, persons younger than 12 years of age
- r4t2, persons 12 years of age and older
- r4t3, Total persons in the household
- tamhog, size of the household
- tamviv, number of persons living in the household
- escolari, years of schooling
- rez_esc, Years behind in school
- hhsize, household size
- paredblolad, =1 if predominant material on the outside wall is block or brick
- paredzocalo, "=1 if predominant material on the outside wall is socket (wood,  zinc or absbesto"
- paredpreb, =1 if predominant material on the outside wall is prefabricated or cement
- pareddes, =1 if predominant material on the outside wall is waste material
- paredmad, =1 if predominant material on the outside wall is wood
- paredzinc, =1 if predominant material on the outside wall is zink
- paredfibras, =1 if predominant material on the outside wall is natural fibers
- paredother, =1 if predominant material on the outside wall is other
- pisomoscer, =1 if predominant material on the floor is mosaic,  ceramic,  terrazo"
- pisocemento, =1 if predominant material on the floor is cement
- pisoother, =1 if predominant material on the floor is other
- pisonatur, =1 if predominant material on the floor is  natural material
- pisonotiene, =1 if no floor at the household
- pisomadera, =1 if predominant material on the floor is wood
- techozinc, =1 if predominant material on the roof is metal foil or zink
- techoentrepiso, "=1 if predominant material on the roof is fiber cement,  mezzanine "
- techocane, =1 if predominant material on the roof is natural fibers
- techootro, =1 if predominant material on the roof is other
- cielorazo, =1 if the house has ceiling
- abastaguadentro, =1 if water provision inside the dwelling
- abastaguafuera, =1 if water provision outside the dwelling
- abastaguano, =1 if no water provision
- public, =1 electricity from CNFL,  ICE,  ESPH/JASEC
- planpri, =1 electricity from private plant
- noelec, =1 no electricity in the dwelling
- coopele, =1 electricity from cooperative
- sanitario1, =1 no toilet in the dwelling
- sanitario2, =1 toilet connected to sewer or cesspool
- sanitario3, =1 toilet connected to  septic tank
- sanitario5, =1 toilet connected to black hole or letrine
- sanitario6, =1 toilet connected to other system
- energcocinar1, =1 no main source of energy used for cooking (no kitchen)
- energcocinar2, =1 main source of energy used for cooking electricity
- energcocinar3, =1 main source of energy used for cooking gas
- energcocinar4, =1 main source of energy used for cooking wood charcoal
- elimbasu1, =1 if rubbish disposal mainly by tanker truck
- elimbasu2, =1 if rubbish disposal mainly by botan hollow or buried
- elimbasu3, =1 if rubbish disposal mainly by burning
- elimbasu4, =1 if rubbish disposal mainly by throwing in an unoccupied space
- elimbasu5, "=1 if rubbish disposal mainly by throwing in river,  creek or sea"
- elimbasu6, =1 if rubbish disposal mainly other
- epared1, =1 if walls are bad
- epared2, =1 if walls are regular
- epared3, =1 if walls are good
- etecho1, =1 if roof are bad
- etecho2, =1 if roof are regular
- etecho3, =1 if roof are good
- eviv1, =1 if floor are bad
- eviv2, =1 if floor are regular
- eviv3, =1 if floor are good
- dis, =1 if disable person
- male, =1 if male
- female, =1 if female
- estadocivil1, =1 if less than 10 years old
- estadocivil2, =1 if free or coupled uunion
- estadocivil3, =1 if married
- estadocivil4, =1 if divorced
- estadocivil5, =1 if separated
- estadocivil6, =1 if widow/er
- estadocivil7, =1 if single
- parentesco1, =1 if household head
- parentesco2, =1 if spouse/partner
- parentesco3, =1 if son/doughter
- parentesco4, =1 if stepson/doughter
- parentesco5, =1 if son/doughter in law
- parentesco6, =1 if grandson/doughter
- parentesco7, =1 if mother/father
- parentesco8, =1 if father/mother in law
- parentesco9, =1 if brother/sister
- parentesco10, =1 if brother/sister in law
- parentesco11, =1 if other family member
- parentesco12, =1 if other non family member
- idhogar, Household level identifier
- hogar_nin, Number of children 0 to 19 in household
- hogar_adul, Number of adults in household
- hogar_mayor, # of individuals 65+ in the household
- hogar_total, # of total individuals in the household
- dependency, Dependency rate, calculated = (number of members of the household younger than 19 or older than 64)/(number of member of household between 19 and 64)
- edjefe, years of education of male head of household, based on the interaction of escolari (years of education), head of household and gender, yes=1 and no=0
- edjefa, years of education of female head of household, based on the interaction of escolari (years of education), head of household and gender, yes=1 and no=0
- meaneduc,average years of education for adults (18+)
- instlevel1, =1 no level of education
- instlevel2, =1 incomplete primary
- instlevel3, =1 complete primary
- instlevel4, =1 incomplete academic secondary level
- instlevel5, =1 complete academic secondary level
- instlevel6, =1 incomplete technical secondary level
- instlevel7, =1 complete technical secondary level
- instlevel8, =1 undergraduate and higher education
- instlevel9, =1 postgraduate higher education
- bedrooms, number of bedrooms
- overcrowding, # persons per room
- tipovivi1, =1 own and fully paid house
- tipovivi2, "=1 own,  paying in installments"
- tipovivi3, =1 rented
- tipovivi4, =1 precarious
- tipovivi5, "=1 other(assigned,  borrowed)"
- computer, =1 if the household has notebook or desktop computer
- television, =1 if the household has TV
- mobilephone, =1 if mobile phone
- qmobilephone, # of mobile phones
- lugar1, =1 region Central
- lugar2, =1 region Chorotega
- lugar3, =1 region Pacfico central
- lugar4, =1 region Brunca
- lugar5, =1 region Huetar Atlantica
- lugar6, =1 region Huetar Norte
- area1, =1 zona urbana
- area2, =2 zona rural
- age, Age in years
- SQBescolari, escolari squared
- SQBage, age squared
- SQBhogar_total, hogar_total squared
- SQBedjefe, edjefe squared
- SQBhogar_nin, hogar_nin squared
- SQBovercrowding, overcrowding squared
- SQBdependency, dependency squared
- SQBmeaned, square of the mean years of education of adults (>=18) in the household
- agesq, Age squared
- Target - the target is an ordinal variable indicating groups of income levels. 
    - 1 = extreme poverty 
    - 2 = moderate poverty 
    - 3 = vulnerable households 
    - 4 = non vulnerable households
    
Our goal is to accurately predict where each individual falls in the Target variable.


# Data Cleaning and Exploration

There are several variables, such as SQBescolari, SQBage, SQBhogar_total, SQBedjefe, SQBhogar_nin, SQBovercrowding, SQBdependency, SQBmeaned, agesq, that are either irrelevant in the analysis, or hold little value to the outcome of the analysis. These variables are squares of other existing variables so they are removed from the dataset to avoid any colinearity. Additional data cleaning steps address missing values, standardize data formats, and compute new variables to ensure the dataset is ready for analysis. Missing values are filled with logical defaults or calculated averages. One example of this is replacing v2a1 (rent payment) and v18q1 (tablets owned) with zero, or using the mean education level for specific age groups to impute meaneduc. Categorical variables, like edjefa and edjefe, are converted into binary numeric formats. Dependency ratios are recalculated at the household level using age group distributions, and a binary indicator for school attendance is created.

Once these steps have been executed, new variables are made to address the ambiguity of some of the existing features. Some of these variables create household-level summaries, such as counts of individuals in school, children behind in school, and disabled members, and identifies households with non-family members. A filter is applied to the dataset to include only heads of households and removes redundant or constant features. Housing quality is quantified through composite scores for interior, exterior, and overall quality based on materials and utilities. To visualize household dependencies, a simple scatterplot was created.

```{r}
data_cleaner = function(data){
  #remove redundant variables
  data = data %>% select(-c(SQBescolari, SQBage, SQBhogar_total, SQBedjefe,
                            SQBhogar_nin, SQBovercrowding, SQBdependency, SQBmeaned,
                            agesq))
  
  
  
  ### Fill NAs ###
  #colSums(is.na(data))
  
  #6405 v2a1: rent payment
  house_types = cbind(data$v2a1, data$tipovivi1, data$tipovivi2,
                      data$tipovivi3, data$tipovivi4, data$tipovivi5)
  
  colSums(is.na(as.data.frame(house_types) %>% filter(data$tipovivi5 == 1))) 
  #5600 tipovivi1: owned
  #153 tipovivi4: precarious
  #751 tipoivi5: assigned
  
  #assign 0 to NA in v2a1
  data$v2a1[is.na(data$v2a1)] = 0
  
  
  #v18q1 tablets owned:
  tabs = cbind(data$v18q, data$v18q1)
  # NA if zero, so replace with 0.
  data$v18q1[is.na(data$v18q1)] = 0
  
  
  #rez_esc: years behind in school
  school = as.data.frame(cbind(data$rez_esc, data$age))
  school_not_na = school %>% filter(!is.na(school$V1))
  #applies only to those in school (7-17)
  #fill with 0
  #in school binary
  data$in_school = as.numeric(!is.na(data$rez_esc))
  data$rez_esc[is.na(data$rez_esc)] = 0
  
  
  #meaneduc: avg edu for adults
  age18 = data %>% filter(age == 19 | age == 18)
  mean(na.omit(age18$meaneduc)) #13.66
  mean(na.omit(data$meaneduc)) #9.23
  #since small portion (5 obs), fill with mean for age (13.66)
  data$meaneduc[is.na(data$meaneduc)] = 13.66
  
  
  ### Standardize types ###
  #sapply(data, class) 
  
  #edjefe/edjefa
  #yes=1, no=0
  data$edjefa[data$edjefa == 'no'] = 0
  data$edjefa[data$edjefa == 'yes'] = 1
  data$edjefa = as.numeric(data$edjefa)
  
  data$edjefe[data$edjefe == 'no'] = 0
  data$edjefe[data$edjefe == 'yes'] = 1
  data$edjefe = as.numeric(data$edjefe)
  
  
  # #dependancy: (number of members of the household younger than 19 or older than 64)/(number of member of household between 19 and 64)         
  table(data$dependency)
  
  #calculate for missing vals (0 if none)
  dependency_calc = data %>%
    group_by(idhogar) %>%
    summarise(count_in_range = sum(age >= 19 & age <= 64),
              count_out_range = sum(!(age >= 19 & age <= 64)),
              ratio = ifelse(count_out_range == 0, 0, count_in_range / count_out_range))
  
  result = inner_join(data, dependency_calc, by = "idhogar")
  result = result %>% select(-c(count_in_range, count_out_range,dependency))
  result$dependency = result$ratio
  data = result %>% select(-c(ratio))
  
  
  
  ##### New Variables #####
  
  #new var for number of people in school by household
  school_count = data %>%
    group_by(idhogar) %>%
    summarise(school_count = sum(in_school == 1))
  
  data = inner_join(data, school_count, by = "idhogar")
  
  
  #count of children behind in school
  children_behind = data %>%
    group_by(idhogar) %>%
    summarise(children_behind = sum(rez_esc != 0))
  
  data = inner_join(data, children_behind, by = "idhogar")
  
  
  #count of disabled people in house
  disabled_count = data %>%
    group_by(idhogar) %>%
    summarise(dis_count = sum(dis == 1))
  
  data = inner_join(data, disabled_count, by = "idhogar")
  
  
  #has non-family in household binary
  non_fam = data %>%
    group_by(idhogar) %>%
    summarise(non_family = as.numeric(any(parentesco12 != 0)))
  
  data = inner_join(data, non_fam, by = "idhogar")
  
  
  #split ids
  numeric_data = data %>% select(-c(Id,idhogar,Target))
  
  #check correlations (spearman for nonlinear)
  # corrs = cor(numeric_data, method = 'spearman') %>%
  #           as.data.frame() %>%
  #           mutate(var1 = rownames(.)) %>%
  #           gather(var2, value, -var1) %>%
  #           arrange(desc(value)) %>%
  #           group_by(value) %>%
  #           filter(row_number()==1)
  # 
  # corrs = corrs[corrs$value >= .7 | corrs$value <= -.7,]
  
  #tamhog, tamviv, r4t3 basically same info
  # male/female, area1/area2, and abast... should be binary
  
  #remove more redundant data
  data = data %>% select(-c(female, area2, abastaguafuera, tamhog, tamviv, v18q,in_school))
  
  
  #which vars are not the same within households
  # independent_vars = data %>%
  #   group_by(idhogar) %>%
  #   summarize(across(everything(), ~ n_distinct(.) > 1)) %>%
  #   select(-idhogar) %>%
  #   summarize(across(everything(), any)) %>%
  #   pivot_longer(cols = everything(), names_to = "Column", values_to = "NotConstant") %>%
  #   filter(NotConstant) %>%
  #   pull(Column)
  # 
  # print(independent_vars)
  
  
  ##### Head of Household Data ####
  
  data_hh = data %>%
    filter(parentesco1 == 1) %>%
    select(-c(r4h1,r4h2,r4h3,r4m1,r4m2,r4m3,r4t2,r4t3,
              mobilephone,edjefe,edjefa,dis, #redundant
              parentesco1,parentesco2,parentesco3,parentesco4,parentesco5,
              parentesco6,parentesco7,parentesco8,parentesco9,parentesco10,
              parentesco11,parentesco12, #all are in parentesco1, so useless
              elimbasu5, estadocivil1, #all zero
              Id, idhogar
              ))
  
  #which(colSums(data_hh) == 0) #remove 0s
  
  ### House quality variable ###
  
  #pisonotiene: no floor
  #pareddes: waste walls
  #cielorazo=0: no ceiling
  #noelec
  #sanitario1: no toilet
  #energcocinar1: no kitchen
  #refrig=0: no refridgerator
  
  #epared1-3: wall quality
  #etecho1-3:roof quality
  #eviv: floor quality
  
  house_vars = data_hh %>%
    select(c(pisonotiene,pareddes,cielorazo,noelec,sanitario1,refrig,
             energcocinar1,epared1,epared2,epared3,etecho1,etecho2,
             etecho3,eviv1,eviv2,eviv3))
  
  #flip binary to make same as others
  house_vars$refrig = as.numeric(house_vars$refrig == 0)
  house_vars$cielorazo = as.numeric(house_vars$cielorazo == 0)
  
  #exterior vars
  house_vars$wall_qual = ifelse(house_vars$epared1 == 1, 0,
              ifelse(house_vars$epared2 == 1, .5,
              ifelse(house_vars$epared3 == 1, 1,999)))
  
  house_vars$roof_qual = ifelse(house_vars$etecho1 == 1, 0,
              ifelse(house_vars$etecho2 == 1, .5,
              ifelse(house_vars$etecho3 == 1, 1,999)))
  
  house_vars$floor_qual = ifelse(house_vars$eviv1 == 1, 0,
              ifelse(house_vars$eviv2 == 1, .5,
              ifelse(house_vars$eviv3 == 1, 1,999)))
  
  house_vars$exterior_qual = house_vars %>%
    select(roof_qual,wall_qual,floor_qual) %>%
    rowMeans()
  
  #interior vars
  house_vars$interior_qual = house_vars %>%
    select(pisonotiene,pareddes,cielorazo,noelec,sanitario1,energcocinar1,refrig) %>%
    rowMeans()
  
  house_vars$interior_qual = 1-house_vars$interior_qual
  
  
  house_vars = house_vars %>% select(-c(epared1,epared2,epared3,
                                        etecho1,etecho2,etecho3,
                                        eviv1,eviv2,eviv3))
  
  house_vars$house_qual = house_vars %>%
    select(interior_qual, exterior_qual) %>%
    rowMeans()
  
  #put back in full dataset
  data_hh$interior_qual = house_vars$interior_qual
  data_hh$exterior_qual = house_vars$exterior_qual
  data_hh$house_qual = house_vars$house_qual
  
  return(data_hh)
}

data = data_cleaner(read.csv('poverty.csv'))
test_data = data_cleaner(read.csv('poverty-test-blinded.csv')) #works on test data.
```

```{r}
ggplot(data, aes(x = dependency, y = house_qual)) +
  geom_point(alpha = 0.6, color = "blue") + 
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  labs(
    title = "Scatterplot of Dependency vs House Quality",
    x = "Dependency Ratio",
    y = "House Quality Score"
  ) +
  theme_minimal()
```

As we can see from this plot, as dependency ratio increases, the house quality seems to have a slightly larger spread which could indicate that having more dependents could have an impact on the quality of a household. Another argument that could be made is that people that have more dependents appear to be in a position to provide for these dependents since there seems to be an upward trend of the house quality score as the dependency ratio increases. Additionally, there could be a relationship between the rent paid and the house quality. To view this, another scatterplot was made.

```{r}
ggplot(aes(x = v2a1, y = house_qual, color = dependency), data = data) +
  geom_point() +
  labs(x = "Rent Amount", y = "House Quality", title = "Rent Payment vs House Quality", color = "Dependency Ratio") +
  theme_minimal()
```

As we can see in this plot, there seems to be some sort of relationship when rent goes up, the house quality rises with it. There also seems to be a lower dependency ratio as both rent and house quality increase.

# Model

Classification

* Not sure if the order matters

* Multicategory logit

* Cumulative logit

```{r}
library(nnet)
library(pROC)
library(caret)
library(glmnet)

#split train/test
set.seed(543)
train_ind = sample.int(dim(data)[1], dim(data)[1] * .7)
data_tr = data[train_ind,]
data_te = data[-train_ind,]

#base model (ignore ordering)
mod0 = multinom(Target~., data=data_tr)
probs = predict(mod0, data_te, type = "probs")
preds = predict(mod0, data_te, type = "class")

confusionMatrix(as.factor(preds), as.factor(data_te$Target)) #already decent
```

